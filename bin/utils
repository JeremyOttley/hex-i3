#I am no programmer so it took me a while to realize that there was a better method than writing the same code multiple times in many different scripts. I took the common functions and compiled them into a file called utils.sh. Now all I have to do is source (include) this file from any script I write and I have easy access to a number of handy utilities

#Sourcing these utilities is as simple as writing a single line near the top any bash script(after the crunchbang).
#source $HOME/bin/.scripts/utils.sh

#!/bin/bash

#
# Set Colors
#

bold=$(tput bold)
underline=$(tput sgr 0 1)
reset=$(tput sgr0)

purple=$(tput setaf 171)
red=$(tput setaf 1)
green=$(tput setaf 76)
tan=$(tput setaf 3)
blue=$(tput setaf 38)

#
# Headers and  Logging
#

e_header() { printf "\n${bold}${purple}==========  %s  ==========${reset}\n" "$@"
}
e_arrow() { printf "➜ $@\n"
}
e_success() { printf "${green}✔ %s${reset}\n" "$@"
}
e_error() { printf "${red}✖ %s${reset}\n" "$@"
}
e_warning() { printf "${tan}➜ %s${reset}\n" "$@"
}
e_underline() { printf "${underline}${bold}%s${reset}\n" "$@"
}
e_bold() { printf "${bold}%s${reset}\n" "$@"
}
e_note() { printf "${underline}${bold}${blue}Note:${reset}  ${blue}%s${reset}\n" "$@"
}

#
# USAGE FOR SEEKING CONFIRMATION
# seek_confirmation "Ask a question"
# Credt: https://github.com/kevva/dotfiles
#
# if is_confirmed; then
#   some action
# else
#   some other action
# fi
#

seek_confirmation() {
  printf "\n${bold}$@${reset}"
  read -p " (y/n) " -n 1
  printf "\n"
}

# underlined
seek_confirmation_head() {
  printf "\n${underline}${bold}$@${reset}"
  read -p "${underline}${bold} (y/n)${reset} " -n 1
  printf "\n"
}

# Test whether the result of an 'ask' is a confirmation
is_confirmed() {
if [[ "$REPLY" =~ ^[Yy]$ ]]; then
  return 0
fi
return 1
}

#
# Test whether a command exists
# $1 = cmd to test
# Usage:
# if type_exists 'git'; then
#   some action
# else
#   some other action
# fi
#

type_exists() {
if [ $(type -P $1) ]; then
  return 0
fi
return 1
}

#
# Test which OS the user runs
# $1 = OS to test
# Usage: if is_os 'darwin'; then
#

is_os() {
if [[ "${OSTYPE}" == $1* ]]; then
  return 0
fi
return 1
}

#
# Pushover Notifications
# Usage: pushover "Title Goes Here" "Message Goes Here"
# Credit: http://ryonsherman.blogspot.com/2012/10/shell-script-to-send-pushover.html
#

pushover () {
    PUSHOVERURL="https://api.pushover.net/1/messages.json"
  API_KEY="your-api-here"
  USER_KEY="your-user-key-here"
    DEVICE=""

    TITLE="${1}"
    MESSAGE="${2}"

    curl \
    -F "token=${API_KEY}" \
    -F "user=${USER_KEY}" \
    -F "device=${DEVICE}" \
    -F "title=${TITLE}" \
    -F "message=${MESSAGE}" \
    "${PUSHOVERURL}" > /dev/null 2>&1
}

#
# Given a list of desired items and installed items, return a list
# of uninstalled items. Arrays in bash are insane (not in a good way).
# Credit: https://github.com/cowboy/dotfiles
#

function to_install() {
  local debug desired installed i desired_s installed_s remain
  if [[ "$1" == 1 ]]; then debug=1; shift; fi
    # Convert args to arrays, handling both space- and newline-separated lists.
    read -ra desired < <(echo "$1" | tr '\n' ' ')
    read -ra installed < <(echo "$2" | tr '\n' ' ')
    # Sort desired and installed arrays.
    unset i; while read -r; do desired_s[i++]=$REPLY; done < <(
      printf "%s\n" "${desired[@]}" | sort
    )
    unset i; while read -r; do installed_s[i++]=$REPLY; done < <(
      printf "%s\n" "${installed[@]}" | sort
    )
    # Get the difference. comm is awesome.
    unset i; while read -r; do remain[i++]=$REPLY; done < <(
      comm -13 <(printf "%s\n" "${installed_s[@]}") <(printf "%s\n" "${desired_s[@]}")
  )
  [[ "$debug" ]] && for v in desired desired_s installed installed_s remain; do
    echo "$v ($(eval echo "\${#$v[*]}")) $(eval echo "\${$v[*]}")"
  done
  echo "${remain[@]}"
}

#https://natelandau.com/bash-scripting-utilities/

#!/usr/bin/env bash

alias not='!'

# convenience output functions

function fatal {
	printf "FATAL: ${*}\n"
	exit 1
}

function fatal! {
	>&2 printf "FATAL: ${*}\n"
	exit 1
}

function error {
	printf "ERROR: ${*}\n"
}

alias err=error

function error! {
	>&2 printf "ERROR: ${*}\n"
}

alias err!=error!

function warn {
	printf "WARNING: ${*}\n"
}

function warn! {
	>&2 printf "WARNING: ${*}\n"
}

function info {
	printf "INFO: ${*}\n"
}

function info! {
	>&2 printf "INFO: ${*}\n"
}

# file/string checking functions

function exists? {
	[[ -e "${1}" ]]
	return ${?}
}

function file? {
	[[ -f "${1}" ]]
	return ${?}
}

function directory? {
	[[ -d "${1}" ]]
	return ${?}
}

alias dir?=directory?

function readable? {
	[[ -r "${1}" ]]
	return ${?}
}

alias read?=readable?

function writeable? {
	[[ -w "${1}" ]]
	return ${?}
}

alias write?=writeable?

function executable? {
	[[ -x "${1}" ]]
	return ${?}
}

alias exec?=executable?

function empty? {
	[[ -z "${1}" ]]
	return ${?}
}

function nonempty? {
	[[ -n "${1}" ]]
	return ${?}
}

function number? {
	case "${1}" in
		''|*[!0-9]* ) return 1 ;;
		* ) return 0 ;;
	esac
}

# dependency/compatibility functions

function installed? {
	if empty? "${1}"; then
		error! "${FUNCNAME[0]}: missing argument"
		return 1
	else
		local cmd=$(command -v "${1}")

		nonempty? "${cmd}" && file? "${cmd}"
		return ${?}
	fi
}

function require {
	if empty? "{1}"; then
		error! "${FUNCNAME[0]}: missing argument"
	else
		local func="__require_${1}"

		if [[ $(type -t ${func}) != "function" ]]; then
			error! "require: unknown requirement: ${1}"
		else
			${func}
			return ${?}
		fi
	fi
}

function require! {
	if empty? "${1}"; then
		error! "${FUNCNAME[0]}: missing argument"
		return 1
	else
		require "${1}" || (error! "unsatisfied requirement: ${1}" ; return 1)
	fi
}

function __require_bash2 {
	[[ "${BASH_VERSINFO[0]}" -eq 2 ]]
	return ${?}
}

function __require_bash3 {
	[[ "${BASH_VERSINFO[0]}" -eq 3 ]]
	return ${?}
}

function __require_bash4 {
	[[ "${BASH_VERSINFO[0]}" -eq 4 ]]
	return ${?}
}

function __require_bash5 {
	[[ "${BASH_VERSINFO[0]}" -eq 5 ]]
	return ${?}
}

function __version_python {
	local py_vers="python -c 'import sys; print(sys.version_info[0])'"
	eval ${py_vers}
}

function __require_python {
	installed? python
	return ${?}
}

function __require_python2 {
	installed? python2 || [[ $(__version_python) -eq 2 ]]
	return ${?}
}

function __require_python3 {
	installed? python3 || [[ $(__version_python) -eq 3 ]]
	return ${1}
}

function __version_perl {
	local pl_vers="perl -e 'print int($]);'"
	eval ${pl_vers}
}

function __require_perl {
	installed? perl
	return ${?}
}

function __require_perl5 {
	installed? perl && [[ $(__version_perl) -eq 5 ]]
	return ${?}
}

function __version_ruby {
	local rb_vers="ruby -e 'puts RUBY_VERSION[0..2]'"
	eval ${rb_vers}
}

function __require_ruby {
	installed? ruby
	return ${?}
}

function __require_ruby18 {
	installed? ruby1.8 || [[ $(__version_ruby) = "1.8" ]]
	return ${?}
}

function __require_ruby19 {
	installed? ruby1.9.1 || installed? ruby1.9.2 || installed? ruby1.9.3 || \
		[[ $(__version_ruby) = "1.9" ]]
	return ${?}
}

function __require_ruby20 {
	installed? ruby2.0 || [[ $(__version_ruby) = "2.0" ]]
	return ${?}
}

function __require_ruby21 {
	installed? ruby2.1 || [[ $(__version_ruby) = "2.1" ]]
	return ${?}
}

function __require_ruby22 {
	installed? ruby2.2 || [[ $(__version_ruby) = "2.2" ]]
	return ${?}
}

function __require_ruby23 {
	installed? ruby2.3 || [[ $(__version_ruby) = "2.3" ]]
	return ${?}
}

function __require_ruby24 {
	installed? ruby2.4 || [[ $(__version_ruby) = "2.4" ]]
	return ${?}
}

#Convenient output functions:
#$ info "foo not found" # "INFO: foo not found"
#$ error "foo not found" # "ERROR: foo not found"
#$ warn "foo not found" # "WARNING: foo not found"
#$ fatal "foo not found" # "FATAL: foo not found" and exits with $? 1

#(Less) painful dependency/compatibility checking:
#$ installed? jq || (error! "i need jq" && exit 1)
#$ require bash4 || (error! "this script only works on bash 4 and above" && exit)

#(Less) painful file and string checking:
#$ exists? /etc/passwd && info "found /etc/passwd"
#$ file? /usr || warn "not a regular file"
#$ directory? /bin && info "found /bin"

#$ readable? /var/log/syslog
#$ writeable? ~/.bashrc
#$ executable? /bin/ls

#$ empty? "${foo}"
#$ nonempty? "${foo}"
